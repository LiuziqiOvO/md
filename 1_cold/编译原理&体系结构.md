课外教材：

龙书，虎书，鲸书

工具：

flex，bison

antlr，llvm10



#### SysY语言

C语言的子集



arm环境

arm-linux-gnueabihf-gcc + qemu-arm



## 前言



词法分析->语法分析->语义分析（前端）//新的语言

->中间代码生成->代码优化->目标代码生成（后端）//新的硬件平台

#### 词法分析

Lexical

- 字面量（literal）：3,5,helloworld
- 保留字
- 标识符
- 运算符
- 界符

把代码切分成一个个Token

#### 语法分析

parsing语法检查（规约或推导）

AST：抽象语法树，把Token转换成树



## 文法

文法

语言

(计算理论已讲)

#### 文法类型

(乔姆斯基)

1. 0型文法，图灵机左侧至少含有一个非终结符
2. 1型文法，上下文有关文法，左边不能比右边长（生成空的产生式除外）
3. 2型文法，上下文无关文法，左边只有一个终结符
4. 3型文法，正则文法，有限自动机（多用右线性正则文法，左线性一般忽略，二者可以替换）

程序语言——上下文无关文法

最右推导——规范推导，对应规范规约

（规约就是推导的逆过程）

## 词法分析

把字母流分割成单词

正则表达式（正规式），正则语言（正规集）

所有的词法结构都可以正则化

若两个正则式对应的语言相同，则这两个正则式等价
$$
b(ab)^* = (ba)^*a
$$

正则文法与正则表达式之间的互相转换











#### DFA

每个状态+每个字符都有唯一确定的下一状态.

#### NFA



NFA->DFA的转换

列表，初始状态集（S的空闭包），按各个字母分别找下一个状态空闭包，如果表里没有这些空闭包，添加，继续找下一状态闭包。改名：每个闭包就是DFA的一个状态



NFA的化简

与正则表达式的转换

### 自动构造工具

LLVM-IR

#### FLEX

```
%option yylineno noyywrap
%option c++
%{
	c/c++ code (will be copy by flex)
%}
正则表达式
%%

```



## 语法分析

确定的自顶向下语法分析

非终结符的替换：最左推导

发现：如果，每个产生式第一个字符都是唯一确定的，且无重复就无需选择。进一步，如果每个产生式





选择的过程就变为求select（S - > a）

LL(1)文法：像上述不存在产生式产生交集选择困难。



字的由来 L：从左向右分析token，	L：最左推导，

​	1：只看一个符号



#### LR（0）

规约.

· 表示现在读到哪个，点后面是“期待的”

一个方框表示一个聚合状态。



移进,规约冲突



#### SR（1）



### 6.4 LR(1)

意味着还要向后再看一个符号，来选择下一步啥（区分冲突）。叫向前搜索符

身后有物，是身后第一个符号，身后没有就继承之前的。

- LR(1) DFA的构造
- 填写分析表：移进，规约

#### LALR(1)

观察各个状态，产生式完全一样的项目（同心集）有机会合并，

合并以后可能会有规约规约冲突。（当然LALR（1）是从LR(1)过来的， 已经没有移进规约冲突了。）







# 体系结构

CPI，MIPS，加速比的计算

流水线的时空图，计算

非线性流水线的调度：冲突向量







### 流水线

结构冲突：同一时间访问存储器

数据冲突：

- 还没写入就要读。
- 写后写冲突（有多个阶段可以输出，输出顺序错误）
- 还没写就读出去了

气泡，重定向，软件调度（从编译器级别重新组织指令）

控制冲突：分支指令改变PC带来控制冲突。

可以将分支计算提高到ID段，就只有一个周期的延迟；增加延迟槽，



##### 流水线的性能指标



##### 非线性流水线的调度

启动距离

禁用启动距离：会冲突的时间间隔

预约表



题目：一张预约表，横轴是t，纵轴是要使用的部件。根据预约表，写出进制表：根据每一行（每个部件）作出两次使用之差。写出冲突向量。

写出所有调度方案，算平均时间间隔最短的。

时间间隔一样也有不同的。要考虑工作负载的不同情况。



### 指令级并行及其开发

（乱序执行，换名，托马斯托算法。）



### 6 基本指令调度和循环展开



一般认为寄存器只有一个周期访问延迟,与ALU速度匹配

一级Cahce 3-5个周期（指令与数据存储分离）

二级Cache 10个（每个核私有）

三级Cache 片下Cache 



### 7 存储系统

